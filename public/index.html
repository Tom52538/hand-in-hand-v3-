// Globale Variablen
    let currentWorkEntryId = null; // H√§lt die ID des aktuell offenen Arbeitszeit-Eintrags
    let currentBalanceData = null; // H√§lt die Daten der letzten Berechnung f√ºr PDF

    // ==== DOM-Referenzen ====
    // Benutzerseite
    const employeeSelect = document.getElementById('employeeSelect');
    const workTimeBtn = document.getElementById('workTimeBtn');
    const displayDateInput = document.getElementById('displayDate');
    const displayStartTimeInput = document.getElementById('displayStartTime');
    const displayEndTimeInput = document.getElementById('displayEndTime');
    const bookingDetailsDiv = document.getElementById('bookingDetails');
    const summaryHoursDiv = document.getElementById('summaryHours');
    const dailyTotalHoursSpan = document.getElementById('dailyTotalHours');
    const monthlyTotalHoursSpan = document.getElementById('monthlyTotalHours');
    // Admin Login
    const adminLoginFormElement = document.getElementById('adminLoginForm');
    const adminPasswordInput = document.getElementById('adminPassword');
    // Admin Tabs & Content
    const adminTabsContainer = document.getElementById('adminTabs');
    const workHoursTabContent = document.getElementById('tab-workhours');
    const employeesTabContent = document.getElementById('tab-employees');
    const absencesTabContent = document.getElementById('tab-absences');
    const reportsTabContent = document.getElementById('tab-reports');
    // Arbeitszeiten Tab Elemente
    const filterEmployeeSelect = document.getElementById('filterEmployeeSelect');
    const filterMonthInput = document.getElementById('filterMonthInput');
    const applyWorkHoursFilterBtn = document.getElementById('applyWorkHoursFilter');
    const workHoursTableBody = document.querySelector('#workHoursTable tbody');
    const adminDownloadCsvBtn = document.getElementById('adminDownloadCsv');
    const adminDeleteDataBtn = document.getElementById('adminDeleteData');
    const editWorkHoursSection = document.getElementById('editWorkHoursSection');
    const editWorkHoursForm = document.getElementById('editForm');
    // Mitarbeiter Tab Elemente
    const employeeListBody = document.querySelector('#employeeTable tbody');
    const addEmployeeFormElement = document.getElementById('addEmployeeForm');
    const editEmployeeSection = document.getElementById('editEmployeeSection');
    const editEmployeeFormElement = document.getElementById('editEmployeeForm');
    const addEmployeeSection = document.getElementById('addEmployeeSection');
    // Abwesenheiten Tab Elemente
    const absenceEmployeeSelect = document.getElementById('absenceEmployeeSelect');
    const absencesTableBody = document.querySelector('#absencesTable tbody');
    const addAbsenceForm = document.getElementById('addAbsenceForm');
    const addAbsenceEmployeeIdInput = document.getElementById('addAbsenceEmployeeId');
    const addAbsenceDateInput = document.getElementById('addAbsenceDate');
    const addAbsenceTypeSelect = document.getElementById('addAbsenceType');
    const addAbsenceCommentInput = document.getElementById('addAbsenceComment');
    const addAbsenceSubmitBtn = document.getElementById('addAbsenceSubmitBtn');
    const absenceFormNote = document.getElementById('absenceFormNote');
    // Feiertagsgenerierung Elemente
    const generateHolidaysForm = document.getElementById('generateHolidaysForm');
    const generateHolidaysYearInput = document.getElementById('generateHolidaysYear');
    const generateHolidaysBtn = document.getElementById('generateHolidaysBtn');
    const generateHolidaysResultDiv = document.getElementById('generateHolidaysResult');
    // NEU: Referenzen f√ºr Feiertage l√∂schen Button
    const deleteAllPublicHolidaysBtn = document.getElementById('deleteAllPublicHolidaysBtn');
    const deleteHolidaysResultDiv = document.getElementById('deleteHolidaysResult');

    // Auswertungsformular Elemente
    const balanceForm = document.getElementById('balanceForm');
    const balanceNameSelect = document.getElementById('balanceName');
    const balanceYearInput = document.getElementById('balanceYear');
    const periodTypeSelect = document.getElementById('periodTypeSelect');
    const monthSelectDiv = document.getElementById('monthSelectDiv');
    const balanceMonthInput = document.getElementById('balanceMonth');
    const quarterSelectDiv = document.getElementById('quarterSelectDiv');
    const balanceQuarterSelect = document.getElementById('balanceQuarter');
    const downloadPdfBtn = document.getElementById('downloadPdfBtn');
    const balanceResultDiv = document.getElementById('balanceResult');
    // Formatierungsoptionen f√ºr Datum mit Wochentag
    const dateDisplayOptions = { weekday: 'short', day: '2-digit', month: '2-digit', year: 'numeric' };
    const dateDisplayOptionsUTC = { ...dateDisplayOptions, timeZone: 'UTC' };


    // ==== Initialisierung ====
    document.addEventListener('DOMContentLoaded', () => {
      resetWorkTimeForm();
      loadEmployeeOptions(); // F√ºllt Haupt-Dropdown und Admin-Dropdowns gleichzeitig
      setupEventListeners();
      const now = new Date();
      // Setze Standardwerte f√ºr Auswertungen und Feiertagsgenerierung
      const currentYear = now.getFullYear();
      const currentMonth = now.getMonth() + 1;
      if(balanceYearInput) balanceYearInput.value = currentYear;
      if(balanceMonthInput) balanceMonthInput.value = currentMonth;
      if(periodTypeSelect) periodTypeSelect.value = 'MONTH';
      handlePeriodTypeChange(); // Stellt sicher, dass die korrekten Felder angezeigt werden
      if(generateHolidaysYearInput) generateHolidaysYearInput.value = currentYear;
      if(filterMonthInput) { // Standardfilter auf aktuellen Monat setzen
         filterMonthInput.value = `${currentYear}-${String(currentMonth).padStart(2, '0')}`;
      }
    });

    // ==== Event Listener Setup ====
    function setupEventListeners() {
        // Benutzerseite
        if (employeeSelect) employeeSelect.addEventListener('change', handleEmployeeSelection);
        else console.error("Element not found: employeeSelect");
        if (workTimeBtn) workTimeBtn.addEventListener('click', handleWorkTimeToggle); else console.error("Element not found: workTimeBtn");
        // Admin
        if (adminLoginFormElement) adminLoginFormElement.addEventListener('submit', handleAdminLogin); else console.error("Element not found: adminLoginForm");
        // Tabs
        document.querySelectorAll('.tabs li').forEach(tab => {
            if(tab) tab.addEventListener('click', handleTabSwitch); else console.error("Element not found: .tabs li");
        });
        // Arbeitszeiten Tab
        if (applyWorkHoursFilterBtn) applyWorkHoursFilterBtn.addEventListener('click', loadAdminWorkHours); else console.error("Element not found: applyWorkHoursFilter");
        if (adminDownloadCsvBtn) adminDownloadCsvBtn.addEventListener('click', downloadAdminCsv); else console.error("Element not found: adminDownloadCsv");
        if (adminDeleteDataBtn) adminDeleteDataBtn.addEventListener('click', deleteAllWorkHours); else console.error("Element not found: adminDeleteData");
        // Formular im Edit-Bereich wird √ºber Buttons getriggert (onclick)

        // Mitarbeiter Tab
        if (addEmployeeFormElement) addEmployeeFormElement.addEventListener('submit', handleAddEmployee);
        else console.error("Element not found: addEmployeeForm");
        // Edit-Formular wird √ºber Buttons getriggert (onclick)

        // Abwesenheiten Tab
        if (absenceEmployeeSelect) absenceEmployeeSelect.addEventListener('change', handleAbsenceEmployeeSelectChange);
        else console.error("Element not found: absenceEmployeeSelect");
        if (addAbsenceForm) addAbsenceForm.addEventListener('submit', handleAddAbsence); else console.error("Element not found: addAbsenceForm");
        if (generateHolidaysBtn) generateHolidaysBtn.addEventListener('click', handleGenerateHolidays);
        else console.error("Element not found: generateHolidaysBtn");
        if (deleteAllPublicHolidaysBtn) deleteAllPublicHolidaysBtn.addEventListener('click', handleDeleteAllPublicHolidays); else console.error("Element not found: deleteAllPublicHolidaysBtn");
        // Auswertungen Tab
        if (balanceForm) balanceForm.addEventListener('submit', handleCalculateBalance); else console.error("Element not found: balanceForm");
        if (periodTypeSelect) periodTypeSelect.addEventListener('change', handlePeriodTypeChange); else console.error("Element not found: periodTypeSelect");
        if (downloadPdfBtn) downloadPdfBtn.addEventListener('click', handleDownloadPdf); else console.error("Element not found: downloadPdfBtn");
    }

    // ==== Allgemeine Hilfsfunktionen ====
    async function fetchEmployees() {
        try {
            const response = await fetch('/employees'); // √ñffentlicher Endpunkt
            if (!response.ok) throw new Error(`Laden der Mitarbeiterliste fehlgeschlagen (${response.status}).`);
            return await response.json();
        } catch (err) {
            console.error("Fehler beim Laden der Mitarbeiterliste:", err);
            alert("‚ùå Fehler: Mitarbeiterliste konnte nicht geladen werden. " + err.message);
            return []; // Leeres Array zur√ºckgeben, um Folgefehler zu vermeiden
        }
    }

    // F√ºllt ein <select> Element mit Optionen aus der Mitarbeiterliste
    function populateSelectWithOptions(selectElement, employees, useIdAsValue = false, defaultOptionText = "Bitte ausw√§hlen", includeAllOption = false, allOptionValue = "") {
        if (!selectElement) {
            console.error("populateSelectWithOptions: Ung√ºltiges Select-Element √ºbergeben!");
            return;
        }
        // Vorherige Optionen l√∂schen, au√üer dem Standard-Platzhalter
        selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`; // Verwende leeren String als Standardwert

        // Option "Alle Mitarbeiter" hinzuf√ºgen, falls gew√ºnscht
        if(includeAllOption && filterEmployeeSelect === selectElement) { // Nur f√ºr den Filter-Dropdown
             const allOption = document.createElement('option');
             allOption.value = allOptionValue || "all"; // Wert f√ºr "Alle"
             allOption.textContent = "Alle Mitarbeiter";
             selectElement.appendChild(allOption);
        }

        // Mitarbeiter-Optionen hinzuf√ºgen
        employees.forEach(emp => {
            const option = document.createElement('option');
            option.value = useIdAsValue ? emp.id : emp.name; // Wert ist ID oder Name
            option.textContent = emp.name; // Text ist immer Name
            selectElement.appendChild(option);
        });
    }

    // L√§dt Mitarbeiter und bef√ºllt ALLE relevanten Dropdowns
    async function loadEmployeeOptions() {
        const employees = await fetchEmployees();
        // Haupt-Dropdown (Benutzer)
        populateSelectWithOptions(employeeSelect, employees, false, "Bitte ausw√§hlen"); // Wert = Name

        // Admin-Filter-Dropdown (Arbeitszeiten)
        populateSelectWithOptions(filterEmployeeSelect, employees, true, "Alle Mitarbeiter", true, ""); // Wert = ID, Standardwert leer, "Alle" Option

        // Admin-Dropdown (Abwesenheiten)
        populateSelectWithOptions(absenceEmployeeSelect, employees, true, "Bitte ausw√§hlen..."); // Wert = ID

        // Admin-Dropdown (Auswertungen)
         populateSelectWithOptions(balanceNameSelect, employees, false, "Bitte ausw√§hlen..."); // Wert = Name

        if (employees.length === 0) {
            console.warn("Keine Mitarbeiter gefunden oder Fehler beim Laden.");
            // Optional: Fehlermeldung in Dropdowns anzeigen
             const errorMsg = '<option value="">Fehler/Keine MA</option>';
             if(employeeSelect) employeeSelect.innerHTML = errorMsg;
             if(filterEmployeeSelect) filterEmployeeSelect.innerHTML = errorMsg;
             if(absenceEmployeeSelect) absenceEmployeeSelect.innerHTML = errorMsg;
             if(balanceNameSelect) balanceNameSelect.innerHTML = errorMsg;
        }
    }

    // ==== Funktionen Zeiterfassung (Benutzer) ====
     function handleEmployeeSelection() {
         if(summaryHoursDiv) summaryHoursDiv.classList.add('hidden'); // Summary bei MA-Wechsel ausblenden
         if(bookingDetailsDiv) bookingDetailsDiv.classList.add('hidden'); // Auch Details ausblenden
         checkNextBookingAction(); // Pr√ºft Status f√ºr neuen MA und zeigt ggf. Details wieder an
     }

     async function checkNextBookingAction() {
         const name = employeeSelect.value;
         resetBookingDetails(); // WICHTIG: resetBookingDetails wird jetzt hier aufgerufen
         workTimeBtn.disabled = true;
         currentWorkEntryId = null;

         if (!name) {
             workTimeBtn.textContent = 'Bitte Mitarbeiter w√§hlen';
             return;
         }

         workTimeBtn.textContent = 'Status wird gepr√ºft...';
         try {
             const response = await fetch(`/next-booking-details?name=${encodeURIComponent(name)}`);
             if (!response.ok) throw new Error(`Fehler ${response.status} beim Abrufen des Buchungsstatus.`);
             const data = await response.json();
             if (data.nextBooking === 'arbeitsende') {
                 workTimeBtn.textContent = 'Arbeitsende buchen';
                 workTimeBtn.style.backgroundColor = 'orange';
                 currentWorkEntryId = data.id;
                 workTimeBtn.disabled = false;
                 if(bookingDetailsDiv) bookingDetailsDiv.classList.remove('hidden'); // Details anzeigen
                 if (data.startDate) {
                     try {
                        // Datum kommt als YYYY-MM-DD vom Server
                        const dateObj = new Date(data.startDate + 'T00:00:00Z'); // Als UTC interpretieren
                        // ** NEUE FORMATIERUNG **
                        displayDateInput.value = dateObj.toLocaleDateString('de-DE', dateDisplayOptionsUTC);
                     } catch(e) {
                         console.error("Fehler beim Formatieren des Startdatums:", e);
                         displayDateInput.value = data.startDate; // Fallback
                     }
                 } else {
                    displayDateInput.value = 'Unbekannt';
                 }
                 displayStartTimeInput.value = data.startTime ? data.startTime + " Uhr" : 'Unbekannt';
                 displayEndTimeInput.value = '---';
             } else {
                 workTimeBtn.textContent = 'Arbeitsbeginn buchen';
                 workTimeBtn.style.backgroundColor = ''; // Standardfarbe resetten
                 workTimeBtn.disabled = false;
             }
         } catch (error) {
             console.error("Fehler beim Pr√ºfen des n√§chsten Buchungsschritts:", error);
             alert("‚ùå Fehler beim Abrufen des Buchungsstatus: " + error.message);
             workTimeBtn.textContent = 'Fehler beim Laden';
         }
     }

      async function handleWorkTimeToggle() {
         const name = employeeSelect.value;
         if (!name) return;

         const action = workTimeBtn.textContent.includes('Arbeitsbeginn') ? 'start' : 'end';
         const now = new Date();
         const date = now.toISOString().split("T")[0]; // YYYY-MM-DD
         const time = now.toTimeString().slice(0, 5); // HH:MM
         // ** NEUE FORMATIERUNG ** (Lokale Zeit, kein UTC n√∂tig)
         const displayDate = now.toLocaleDateString('de-DE', dateDisplayOptions);
         workTimeBtn.disabled = true;
         workTimeBtn.textContent = 'Buchung wird verarbeitet...';

         if (action === 'start') {
             try {
                 const response = await fetch("/log-start", {
                     method: "POST",
                     headers: { "Content-Type": "application/json" },
                     body: JSON.stringify({ name, date, startTime: time })
                 });
                 const result = await response.json();

                 if (response.ok) {
                     alert("‚úÖ Arbeitsbeginn erfolgreich gebucht.");
                     currentWorkEntryId = result.id;
                     if(bookingDetailsDiv) bookingDetailsDiv.classList.remove('hidden');
                     displayDateInput.value = displayDate; // Formatiertes Datum anzeigen
                     displayStartTimeInput.value = time + " Uhr";
                     displayEndTimeInput.value = '---';
                 } else {
                     throw new Error(result.message || `Serverfehler ${response.status}`);
                 }
             } catch (err) {
                 console.error("Fehler beim Buchen des Arbeitsbeginns:", err);
                 alert("‚ùå Fehler beim Buchen des Arbeitsbeginns: " + err.message);
             } finally {
                 checkNextBookingAction(); // Status neu pr√ºfen (setzt Button etc.)
             }
         } else { // action === 'end'
             if (!currentWorkEntryId) {
                 alert("Fehler: Konnte die ID des offenen Eintrags nicht finden. Bitte Seite neu laden.");
                 checkNextBookingAction();
                 return;
             }
             try {
                 const comment = ""; // Kommentarfeld nicht im UI
                 const response = await fetch(`/log-end/${currentWorkEntryId}`, {
                     method: "PUT",
                     headers: { "Content-Type": "application/json" },
                     body: JSON.stringify({ endTime: time, comment: comment || null })
                 });
                 const result = await response.json();

                 if (response.ok) {
                     alert("‚úÖ Arbeitsende erfolgreich gebucht.");
                     displayEndTimeInput.value = time + " Uhr"; // Endzeit eintragen
                     currentWorkEntryId = null; // ID zur√ºcksetzen

                     // Datum f√ºr die Zusammenfassung holen (aus Anzeige oder aktuell)
                     let summaryDate = date; // Fallback auf aktuelles Datum
                     if(displayDateInput.value && displayDateInput.value !== 'Unbekannt') {
                         // Versuchen, das YYYY-MM-DD aus dem formatierten String zu extrahieren
                         // Annahme: Format "Wochentag. TT.MM.YYYY"
                         const parts = displayDateInput.value.split(' ');
                         if (parts.length > 1) {
                            const dateParts = parts[1].split('.');
                            if (dateParts.length === 3) {
                                summaryDate = `${dateParts[2]}-${dateParts[1].padStart(2,'0')}-${dateParts[0].padStart(2,'0')}`;
                            }
                         }
                     }
                     // ** Stundenzusammenfassung anzeigen **
                     displaySummaryHours(name, summaryDate);
                 } else {
                     throw new Error(result.message || `Serverfehler ${response.status}`);
                 }
             } catch (err) {
                 console.error("Fehler beim Buchen des Arbeitsendes:", err);
                 alert("‚ùå Fehler beim Buchen des Arbeitsendes: " + err.message);
             } finally {
                checkNextBookingAction(); // Status neu pr√ºfen (setzt Button zur√ºck etc.)
             }
         }
     }

     async function displaySummaryHours(employeeName, dayDate) {
         if (!employeeName || !dayDate || !summaryHoursDiv || !dailyTotalHoursSpan || !monthlyTotalHoursSpan) return;
         // Datum muss im YYYY-MM-DD Format sein f√ºr die Abfrage
         let queryDate = dayDate;
         if (!/^\d{4}-\d{2}-\d{2}$/.test(dayDate)) {
            console.error("Ung√ºltiges Datumsformat f√ºr Summary-Anfrage:", dayDate);
            queryDate = new Date().toISOString().split('T')[0]; // Sicherer Fallback
         }

         summaryHoursDiv.classList.remove('hidden'); // Zusammenfassung sichtbar machen
         dailyTotalHoursSpan.textContent = 'lade...';
         monthlyTotalHoursSpan.textContent = 'lade...';
         try {
             const response = await fetch(`/summary-hours?name=${encodeURIComponent(employeeName)}&date=${queryDate}`);
             if (!response.ok) throw new Error(`Fehler ${response.status} beim Laden der Stunden√ºbersicht.`);
             const summary = await response.json();
             dailyTotalHoursSpan.textContent = `${summary.dailyHours ? summary.dailyHours.toFixed(2) : '0.00'} Std.`;
             monthlyTotalHoursSpan.textContent = `${summary.monthlyHours ? summary.monthlyHours.toFixed(2) : '0.00'} Std.`;
         } catch (error) {
             console.error("Fehler beim Anzeigen der Stundenzusammenfassung:", error);
             dailyTotalHoursSpan.textContent = 'Fehler';
             monthlyTotalHoursSpan.textContent = 'Fehler';
         }
     }

     function resetWorkTimeForm() {
         if(employeeSelect) employeeSelect.value = '';
         if(workTimeBtn) {
             workTimeBtn.textContent = 'Bitte Mitarbeiter w√§hlen';
             workTimeBtn.style.backgroundColor = '';
             workTimeBtn.disabled = true;
         }
         resetBookingDetails();
         if(bookingDetailsDiv) bookingDetailsDiv.classList.add('hidden');
         if(summaryHoursDiv) summaryHoursDiv.classList.add('hidden'); // Beim kompletten Reset auch Summary verstecken
     }

     function resetBookingDetails() {
         if(displayDateInput) displayDateInput.value = '';
         if(displayStartTimeInput) displayStartTimeInput.value = '';
         if(displayEndTimeInput) displayEndTimeInput.value = '';
         // if(summaryHoursDiv) summaryHoursDiv.classList.add('hidden'); // <-- Auskommentiert, damit Summary sichtbar bleibt
         if(dailyTotalHoursSpan) dailyTotalHoursSpan.textContent = '--';
         if(monthlyTotalHoursSpan) monthlyTotalHoursSpan.textContent = '--';
         currentWorkEntryId = null;
     }

    // ==== Admin-Funktionen ====
    async function handleAdminLogin(e) {
        e.preventDefault();
        if (!adminPasswordInput || !adminLoginFormElement || !adminTabsContainer) return;
        const password = adminPasswordInput.value;
        if (!password) {
            alert("Bitte Passwort eingeben.");
            return;
        }
        const loginButton = adminLoginFormElement.querySelector('button[type="submit"]');
        loginButton.disabled = true;
        loginButton.textContent = 'Anmeldung l√§uft...';
        try {
            const response = await fetch("/admin-login", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ password }),
                credentials: "include"
            });
            const responseText = await response.text();
            if (response.ok) {
                alert("‚úÖ Admin erfolgreich angemeldet.");
                adminPasswordInput.value = "";
                adminTabsContainer.classList.remove("hidden");
                adminLoginFormElement.classList.add("hidden");
                handleTabSwitch({ currentTarget: document.querySelector('.tabs li[data-tab="workhours"]') }); // Zum ersten Tab wechseln
            } else {
                alert(`‚ùå Login fehlgeschlagen (${response.status}): ${responseText}`);
            }
        } catch (error) {
            console.error("Netzwerkfehler beim Admin-Login:", error);
            alert("‚ùå Netzwerkfehler beim Login. Bitte Server pr√ºfen.");
        } finally {
            loginButton.disabled = false;
            loginButton.textContent = 'Anmelden';
        }
    }

    function handleTabSwitch(event) {
        if (!event || !event.currentTarget) return;
        const clickedTab = event.currentTarget;
        const targetTabName = clickedTab.getAttribute("data-tab");
        if(!targetTabName) return;

        document.querySelectorAll(".tabs li").forEach(t => t.classList.remove("active"));
        document.querySelectorAll(".tab-content").forEach(tc => tc.classList.add("hidden"));

        clickedTab.classList.add("active");
        const targetContentId = "tab-" + targetTabName;
        const targetContent = document.getElementById(targetContentId);

        if (targetContent) {
            targetContent.classList.remove("hidden");

            // Inhalte neu laden oder Initialzustand herstellen beim Tab-Wechsel
            switch (targetTabName) {
                case 'workhours':
                    if (!filterEmployeeSelect.options || filterEmployeeSelect.options.length <= 1) {
                       loadEmployeeOptions(); // Stellt sicher, dass MA geladen sind
                    }
                    // Tabelle nur leeren wenn Filter nicht gesetzt sind? Oder immer? Hier: immer initial anzeigen
                    if (!workHoursTableBody.firstChild || workHoursTableBody.innerHTML.includes('Filter ausw√§hlen')) {
                       workHoursTableBody.innerHTML = '<tr><td colspan="7">Bitte Filter ausw√§hlen und anwenden.</td></tr>';
                    }
                    cancelEditWorkHours(); // Edit-Bereich ausblenden
                    break;
                case 'employees':
                    loadEmployees(); // Mitarbeiterliste immer neu laden
                    cancelEditEmployee(); // Edit-Bereich ausblenden
                    break;
                case 'absences':
                     if (!absenceEmployeeSelect.options || absenceEmployeeSelect.options.length <= 1) {
                       loadEmployeeOptions(); // Stellt sicher, dass MA geladen sind
                     }
                     // Initialzustand: Tabelle leeren, Formular zur√ºcksetzen
                     if(absencesTableBody) absencesTableBody.innerHTML = '<tr><td colspan="5">Bitte Mitarbeiter ausw√§hlen.</td></tr>';
                     if(addAbsenceForm) addAbsenceForm.reset();
                     if(addAbsenceSubmitBtn) addAbsenceSubmitBtn.disabled = true; // Button deaktivieren
                     if(absenceFormNote) absenceFormNote.style.display = 'block'; // Hinweis anzeigen
                     if(addAbsenceEmployeeIdInput) addAbsenceEmployeeIdInput.value = ""; // Verstecktes Feld leeren
                     if(generateHolidaysResultDiv) generateHolidaysResultDiv.innerHTML = ""; // Ergebnis Feiertagsgenerierung l√∂schen
                     if(generateHolidaysYearInput) generateHolidaysYearInput.value = new Date().getFullYear(); // Aktuelles Jahr
                     if(deleteHolidaysResultDiv) deleteHolidaysResultDiv.innerHTML = ""; // Ergebnis Feiertagsl√∂schung l√∂schen
                    break;
                case 'reports':
                    if (!balanceNameSelect.options || balanceNameSelect.options.length <= 1) {
                       loadEmployeeOptions(); // Stellt sicher, dass MA geladen sind
                    }
                    if(balanceResultDiv) balanceResultDiv.innerHTML = ''; // Ergebnisbereich leeren
                    if(downloadPdfBtn) downloadPdfBtn.disabled = true; // PDF-Button deaktivieren
                    handlePeriodTypeChange(); // Korrekte Monats/Quartalsfelder anzeigen
                    currentBalanceData = null; // Keine Daten f√ºr PDF verf√ºgbar
                    break;
            }
        } else {
             console.error(`Tab-Inhalt f√ºr ID '${targetContentId}' nicht gefunden.`);
        }
    }

    // === Arbeitszeiten-Tab Funktionen ===
    async function loadAdminWorkHours() {
        if (!workHoursTableBody || !filterEmployeeSelect || !filterMonthInput || !applyWorkHoursFilterBtn) {
            console.error("Filterelemente oder Tabelle f√ºr Arbeitszeiten nicht gefunden");
            if(workHoursTableBody) workHoursTableBody.innerHTML = `<tr><td colspan='7' class='error-message'>Fehler: UI-Elemente fehlen.</td></tr>`;
            return;
        }
        const employeeId = filterEmployeeSelect.value; // Kann ID oder leer sein
        const monthValue = filterMonthInput.value; // YYYY-MM oder leer

        applyWorkHoursFilterBtn.disabled = true;
        applyWorkHoursFilterBtn.textContent = 'Lade...';
        workHoursTableBody.innerHTML = "<tr><td colspan='7'>Lade Daten...</td></tr>";

        let year = '', month = '';
        if (monthValue) {
            const parts = monthValue.split('-');
            if (parts.length === 2 && parts[0].length === 4 && parts[1].length === 2) {
                year = parts[0];
                month = parts[1];
            } else if (monthValue !== '') { // Nur Fehler anzeigen, wenn etwas eingegeben wurde, das ung√ºltig ist
                workHoursTableBody.innerHTML = "<tr><td colspan='7' style='color:orange;'>Ung√ºltiges Monatsformat. Bitte YYYY-MM verwenden.</td></tr>";
                applyWorkHoursFilterBtn.disabled = false;
                applyWorkHoursFilterBtn.textContent = 'Filter anwenden';
                return; // Stopp, wenn Format ung√ºltig ist
            }
        }
        // Baue URL nur mit vorhandenen Parametern
        let fetchUrl = '/admin-work-hours?';
        const params = [];
        if (employeeId && employeeId !== 'all' && employeeId !== '') {
            params.push(`employeeId=${encodeURIComponent(employeeId)}`);
        }
        if (year && month) {
             params.push(`year=${encodeURIComponent(year)}`);
             params.push(`month=${encodeURIComponent(month)}`);
        }
        fetchUrl += params.join('&');

        try {
            const response = await fetch(fetchUrl, { credentials: "include" });
            if (!response.ok) {
                let errorData = { message: `Serverfehler (${response.status})` };
                try { errorData = await response.json(); }
                catch (e) { try { errorData.message = await response.text(); } catch (e2) {} }
                throw new Error(errorData.message || `Laden der Arbeitszeiten fehlgeschlagen`);
            }
            const data = await response.json();
            workHoursTableBody.innerHTML = ""; // Tabelle leeren

            if (data.length === 0) {
                 workHoursTableBody.innerHTML = "<tr><td colspan='7'>Keine Arbeitszeiten f√ºr die gew√§hlten Filter gefunden.</td></tr>";
            } else {
                data.forEach(entry => {
                    const row = workHoursTableBody.insertRow();
                    const hours = parseFloat(entry.hours) || 0;
                    let displayDate = 'N/A';
                    if (entry.date) {
                        try {
                            // Datum kommt als YYYY-MM-DD String oder Date Objekt
                            const dateStr = (entry.date instanceof Date) ? entry.date.toISOString().split('T')[0] : String(entry.date).split('T')[0];
                            const dateObj = new Date(dateStr + 'T00:00:00Z'); // Als UTC behandeln f√ºr Konsistenz
                            // ** NEUE FORMATIERUNG **
                            displayDate = dateObj.toLocaleDateString("de-DE", dateDisplayOptionsUTC); // Mit Wochentag etc.
                        } catch(e) {
                            displayDate = entry.date; // Fallback
                            console.warn("Admin Datumskonvertierungsfehler:", entry.date, e);
                        }
                    }

                    row.insertCell().textContent = entry.id;
                    row.insertCell().textContent = entry.name || 'Unbekannt';
                    row.insertCell().textContent = displayDate; // <- Verwendet formatiertes Datum
                    row.insertCell().textContent = `${entry.startTime || '--:--'} - ${entry.endTime || '--:--'}`;
                    row.insertCell().textContent = hours.toFixed(2);
                    row.insertCell().textContent = entry.comment || '';

                    const actionCell = row.insertCell();
                    const editButton = document.createElement('button');
                    editButton.textContent = '‚úé';
                    editButton.title = 'Bearbeiten';
                    editButton.style.padding = '4px 8px';
                    editButton.style.marginRight = '5px';
                    editButton.onclick = () => editEntry(entry);
                    actionCell.appendChild(editButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'üóëÔ∏è';
                    deleteButton.title = 'L√∂schen';
                    deleteButton.style.padding = '4px 8px';
                    deleteButton.style.backgroundColor = '#dc3545';
                    deleteButton.style.color = 'white';
                    deleteButton.onclick = () => deleteEntry(entry.id);
                    actionCell.appendChild(deleteButton);
                });
            }
        } catch (error) {
            console.error("Fehler beim Laden der Admin-Arbeitszeiten:", error);
            workHoursTableBody.innerHTML = `<tr><td colspan="7" class="error-message">‚ùå Fehler: ${error.message}</td></tr>`;
        } finally {
            applyWorkHoursFilterBtn.disabled = false;
            applyWorkHoursFilterBtn.textContent = 'Filter anwenden';
        }
    }

    function editEntry(entry) {
        if(!editWorkHoursForm || !editWorkHoursSection) return;
        editWorkHoursForm.elements['id'].value = entry.id;
        editWorkHoursForm.elements['editName'].value = entry.name || "";
        editWorkHoursForm.elements['date'].value = entry.date ? entry.date.split("T")[0] : ""; // Format YYYY-MM-DD
        editWorkHoursForm.elements['startTime'].value = entry.startTime || "";
        editWorkHoursForm.elements['endTime'].value = entry.endTime || "";
        editWorkHoursForm.elements['comment'].value = entry.comment || "";
        editWorkHoursSection.classList.remove("hidden");
        editWorkHoursSection.scrollIntoView({ behavior: "smooth" });
    }

    function cancelEditWorkHours() {
        if (editWorkHoursSection) editWorkHoursSection.classList.add("hidden");
        if (editWorkHoursForm) editWorkHoursForm.reset();
        if (editWorkHoursForm && editWorkHoursForm.elements['id']) editWorkHoursForm.elements['id'].value = ""; // ID zur√ºcksetzen
    }

    async function saveChanges() {
        if (!editWorkHoursForm || !editWorkHoursForm.elements['id']) return;
        const id = editWorkHoursForm.elements['id'].value;
        if (!id) return;

        const data = {
            id: parseInt(id),
            date: editWorkHoursForm.elements['date'].value,
            startTime: editWorkHoursForm.elements['startTime'].value,
            endTime: editWorkHoursForm.elements['endTime'].value,
            comment: editWorkHoursForm.elements['comment'].value
        };

        if (!data.date || !data.startTime || !data.endTime) {
            alert("Bitte Datum, Startzeit und Endzeit ausf√ºllen.");
            return;
        }

        const saveButton = editWorkHoursForm.querySelector('button[onclick="saveChanges()"]');
        saveButton.disabled = true;
        saveButton.textContent = 'Speichern...';

        try {
            const response = await fetch("/api/admin/update-hours", {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(data),
                credentials: "include"
            });
             const resultText = await response.text(); // Erst Text lesen

            if (response.ok) {
                alert("‚úÖ √Ñnderungen erfolgreich gespeichert.");
                cancelEditWorkHours(); // Schlie√üt das Formular
                loadAdminWorkHours(); // L√§dt die Tabelle neu
            } else {
                let errorMessage = resultText;
                try {
                  const errorJson = JSON.parse(resultText); // Versuchen zu parsen
                  errorMessage = errorJson.message || resultText; // JSON-Nachricht oder Text
                } catch(e) { /* War wohl doch nur Text */ }
                alert(`‚ùå Fehler beim Speichern (${response.status}): ${errorMessage}`);
            }
        } catch (error) {
            console.error("Netzwerkfehler beim Speichern der √Ñnderungen:", error);
            alert("‚ùå Netzwerkfehler beim Speichern.");
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Speichern';
        }
    }

    async function deleteEntry(id) {
        if (!confirm(`Sind Sie sicher, dass Sie den Arbeitszeiteintrag mit ID ${id} unwiderruflich l√∂schen m√∂chten?`)) return;

        try {
            const response = await fetch(`/api/admin/delete-hours/${id}`, {
                method: "DELETE",
                credentials: "include"
            });
            const result = await response.text();
            if (response.ok) {
                alert("‚úÖ Eintrag erfolgreich gel√∂scht.");
                loadAdminWorkHours(); // Tabelle neu laden
                cancelEditWorkHours(); // Falls der gel√∂schte Eintrag gerade bearbeitet wurde
            } else {
                alert(`‚ùå Fehler beim L√∂schen (${response.status}): ${result}`);
            }
        } catch (error) {
            console.error(`Netzwerkfehler beim L√∂schen von Eintrag ${id}:`, error);
            alert("‚ùå Netzwerkfehler beim L√∂schen.");
        }
    }

    async function downloadAdminCsv() {
         const employeeId = filterEmployeeSelect.value;
         const monthValue = filterMonthInput.value;
         let year = '', month = '';
         if (monthValue) {
            const parts = monthValue.split('-');
            if (parts.length === 2) { year = parts[0]; month = parts[1]; }
         }

         let downloadUrl = '/admin-download-csv?';
         const params = [];
         if (employeeId && employeeId !== 'all' && employeeId !== '') {
            params.push(`employeeId=${encodeURIComponent(employeeId)}`);
         }
         if (year && month) {
             params.push(`year=${encodeURIComponent(year)}`);
             params.push(`month=${encodeURIComponent(month)}`);
         }
         downloadUrl += params.join('&');
         console.log("Starte CSV-Download f√ºr URL:", downloadUrl);
         // ACHTUNG: window.open kann durch Popup-Blocker verhindert werden!
         // Eine Alternative w√§re, den fetch-Ansatz wie beim PDF zu verwenden,
         // aber f√ºr CSV ist window.open oft ausreichend.
         window.open(downloadUrl, '_blank');
    }

    async function deleteAllWorkHours() {
         if (!confirm('WARNUNG!\n\nSind Sie absolut sicher, dass Sie ALLE Arbeitszeiten, Monatsbilanzen UND Abwesenheiten unwiderruflich l√∂schen m√∂chten?\n\nDIESE AKTION KANN NICHT R√úCKG√ÑNGIG GEMACHT WERDEN!')) return;
         const confirmation = prompt("Bitte geben Sie 'L√ñSCHEN' ein, um fortzufahren:");
         if (confirmation !== 'L√ñSCHEN') {
             alert("L√∂schvorgang abgebrochen.");
             return;
         }
         try {
             const response = await fetch('/adminDeleteData', { method: 'DELETE', credentials: 'include' });
             const result = await response.text();
             if (response.ok) {
                 alert(`‚úÖ ${result}`);
                 // UI zur√ºcksetzen
                 if(workHoursTableBody) workHoursTableBody.innerHTML = '<tr><td colspan="7">Alle Daten gel√∂scht. Bitte Filter erneut anwenden.</td></tr>';
                 if(balanceResultDiv) balanceResultDiv.innerHTML = ''; // Auswertungen leeren
                 if(absencesTableBody) absencesTableBody.innerHTML = '<tr><td colspan="5">Alle Daten gel√∂scht. Bitte Mitarbeiter ausw√§hlen.</td></tr>'; // Abwesenheiten leeren
                 loadEmployees(); // Mitarbeiterliste neu laden (bleibt ja)
                 loadEmployeeOptions(); // Dropdowns neu bef√ºllen
             } else {
                 alert(`‚ùå Fehler beim L√∂schen aller Daten (${response.status}): ${result}`);
             }
         } catch (error) {
             console.error('Netzwerkfehler beim L√∂schen aller Daten:', error);
             alert('‚ùå Netzwerkfehler beim L√∂schen aller Daten.');
         }
    }

    // ==== Mitarbeiterverwaltung ====
    async function loadEmployees() {
        if(!employeeListBody) { console.error("Element nicht gefunden: #employeeList"); return; }
        employeeListBody.innerHTML = "<tr><td colspan='8'>Lade Mitarbeiterliste...</td></tr>";
        try {
            const response = await fetch("/admin/employees", { credentials: "include" });
            if (!response.ok) throw new Error(`Fehler beim Laden der Mitarbeiter (${response.status}).`);
            const data = await response.json();
            employeeListBody.innerHTML = "";
            if (data.length > 0) {
                data.forEach(emp => {
                    const row = employeeListBody.insertRow();
                    row.insertCell().textContent = emp.id;
                    row.insertCell().textContent = emp.name;
                    row.insertCell().textContent = (emp.mo_hours || 0).toFixed(2);
                    row.insertCell().textContent = (emp.di_hours || 0).toFixed(2);
                    row.insertCell().textContent = (emp.mi_hours || 0).toFixed(2);
                    row.insertCell().textContent = (emp.do_hours || 0).toFixed(2);
                    row.insertCell().textContent = (emp.fr_hours || 0).toFixed(2);
                    const actionCell = row.insertCell();
                    const editButton = document.createElement('button');
                    editButton.textContent = '‚úé';
                    editButton.title = 'Bearbeiten';
                    editButton.style.padding = '4px 8px';
                    editButton.style.marginRight = '5px';
                    editButton.onclick = () => editEmployee(emp);
                    actionCell.appendChild(editButton);

                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = 'üóëÔ∏è';
                    deleteButton.title = 'L√∂schen';
                    deleteButton.style.padding = '4px 8px';
                    deleteButton.style.backgroundColor = '#dc3545';
                    deleteButton.style.color = 'white';
                    deleteButton.onclick = () => deleteEmployee(emp.id, emp.name);
                    actionCell.appendChild(deleteButton);
                });
            } else {
                employeeListBody.innerHTML = "<tr><td colspan='8'>Keine Mitarbeiter angelegt.</td></tr>";
            }
        } catch (error) {
            console.error("Fehler beim Laden der Mitarbeiterliste (Admin):", error);
            employeeListBody.innerHTML = `<tr><td colspan='8' class="error-message">‚ùå Fehler: ${error.message}</td></tr>`;
        }
    }

    async function handleAddEmployee(event) {
         event.preventDefault();
         if (!addEmployeeFormElement) return;
         const form = event.target;
         const data = {
             name: form.employeeName.value.trim(),
             mo_hours: parseFloat(form.mo_hours.value) || 0,
             di_hours: parseFloat(form.di_hours.value) || 0,
             mi_hours: parseFloat(form.mi_hours.value) || 0,
             do_hours: parseFloat(form.do_hours.value) || 0,
             fr_hours: parseFloat(form.fr_hours.value) || 0
         };

         if (!data.name) {
             alert("Bitte einen Namen f√ºr den Mitarbeiter eingeben."); return;
         }
         if (Object.values(data).some(val => typeof val === 'number' && val < 0)) {
             alert("Stundenwerte d√ºrfen nicht negativ sein."); return;
         }

         const addButton = form.querySelector('button[type="submit"]');
         addButton.disabled = true;
         addButton.textContent = 'Wird hinzugef√ºgt...';
         try {
             const response = await fetch('/admin/employees', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(data),
                 credentials: 'include'
             });
             if (!response.ok) {
                 const errorResult = await response.text();
                 throw new Error(errorResult || `Serverfehler ${response.status}`);
             }
             const result = await response.json();
             alert(`‚úÖ Mitarbeiter "${result.name}" erfolgreich hinzugef√ºgt.`);
             form.reset(); // Formular zur√ºcksetzen
             loadEmployees(); // Liste neu laden
             loadEmployeeOptions(); // Dropdowns aktualisieren
         } catch (error) {
             console.error('Fehler beim Hinzuf√ºgen des Mitarbeiters:', error);
             alert(`‚ùå Fehler beim Hinzuf√ºgen: ${error.message}`);
         } finally {
             addButton.disabled = false;
             addButton.textContent = 'Hinzuf√ºgen';
         }
    }

    function editEmployee(emp) {
         if (!editEmployeeFormElement || !editEmployeeSection || !addEmployeeSection) return;
         editEmployeeFormElement.elements['id'].value = emp.id;
         editEmployeeFormElement.elements['name'].value = emp.name;
         editEmployeeFormElement.elements['mo_hours'].value = emp.mo_hours || 0;
         editEmployeeFormElement.elements['di_hours'].value = emp.di_hours || 0;
         editEmployeeFormElement.elements['mi_hours'].value = emp.mi_hours || 0;
         editEmployeeFormElement.elements['do_hours'].value = emp.do_hours || 0;
         editEmployeeFormElement.elements['fr_hours'].value = emp.fr_hours || 0;

         editEmployeeSection.classList.remove("hidden");
         addEmployeeSection.classList.add("hidden"); // "Hinzuf√ºgen"-Formular ausblenden
         editEmployeeSection.scrollIntoView({ behavior: "smooth" });
    }

    function cancelEditEmployee() {
        if(editEmployeeSection) editEmployeeSection.classList.add("hidden");
        if(addEmployeeSection) addEmployeeSection.classList.remove("hidden"); // "Hinzuf√ºgen"-Formular wieder anzeigen
        if(editEmployeeFormElement) editEmployeeFormElement.reset();
        if(editEmployeeFormElement && editEmployeeFormElement.elements['id']) editEmployeeFormElement.elements['id'].value = ""; // ID leeren
    }

    async function saveEmployeeChanges() {
         if (!editEmployeeFormElement || !editEmployeeFormElement.elements['id']) return;
         const id = editEmployeeFormElement.elements['id'].value;
         if (!id) return;

         const data = {
             id: parseInt(id),
             name: editEmployeeFormElement.elements['name'].value.trim(),
             mo_hours: parseFloat(editEmployeeFormElement.elements['mo_hours'].value) || 0,
             di_hours: parseFloat(editEmployeeFormElement.elements['di_hours'].value) || 0,
             mi_hours: parseFloat(editEmployeeFormElement.elements['mi_hours'].value) || 0,
             do_hours: parseFloat(editEmployeeFormElement.elements['do_hours'].value) || 0,
             fr_hours: parseFloat(editEmployeeFormElement.elements['fr_hours'].value) || 0
         };

         if (!data.name) { alert("Name darf nicht leer sein."); return; }
         if (Object.values(data).some(val => typeof val === 'number' && val < 0)) { alert("Stundenwerte d√ºrfen nicht negativ sein."); return; }

         const saveButton = editEmployeeFormElement.querySelector('button[onclick="saveEmployeeChanges()"]');
         saveButton.disabled = true;
         saveButton.textContent = 'Speichern...';
         try {
             const response = await fetch(`/admin/employees/${id}`, {
                 method: 'PUT',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(data),
                 credentials: 'include'
             });
             const result = await response.text();
             if (response.ok) {
                 alert(`‚úÖ Mitarbeiterdaten erfolgreich aktualisiert.`);
                 cancelEditEmployee(); // Formular ausblenden/zur√ºcksetzen
                 loadEmployees(); // Liste neu laden
                 loadEmployeeOptions(); // Dropdowns aktualisieren
             } else {
                 alert(`‚ùå Fehler beim Aktualisieren (${response.status}): ${result}`);
             }
         } catch (error) {
             console.error("Netzwerkfehler beim Speichern der Mitarbeiter√§nderungen:", error);
             alert("‚ùå Netzwerkfehler beim Aktualisieren.");
         } finally {
             saveButton.disabled = false;
             saveButton.textContent = 'Speichern';
         }
    }

    async function deleteEmployee(id, name) {
        if (!confirm(`ACHTUNG!\n\nSind Sie sicher, dass Sie den Mitarbeiter "${name}" (ID: ${id}) und ALLE seine zugeh√∂rigen Daten (Arbeitszeiten, Bilanzen, Abwesenheiten) unwiderruflich l√∂schen m√∂chten?\n\nDIESE AKTION KANN NICHT R√úCKG√ÑNGIG GEMACHT WERDEN!`)) return;

        try {
            const response = await fetch(`/admin/employees/${id}`, {
                method: 'DELETE',
                credentials: 'include'
            });
            const result = await response.text();
            if (response.ok) {
                alert(`‚úÖ Mitarbeiter "${name}" und alle zugeh√∂rigen Daten erfolgreich gel√∂scht.`);
                loadEmployees(); // Liste neu laden
                loadEmployeeOptions(); // Dropdowns aktualisieren
                // Pr√ºfen ob der gel√∂schte MA in anderen Tabs ausgew√§hlt war und UI zur√ºcksetzen
                if(filterEmployeeSelect && filterEmployeeSelect.value === String(id)) {
                     filterEmployeeSelect.value = "";
                     if(workHoursTableBody) workHoursTableBody.innerHTML = '<tr><td colspan="7">Gel√∂schter Mitarbeiter war ausgew√§hlt. Bitte Filter anwenden.</td></tr>';
                }
                if(absenceEmployeeSelect && absenceEmployeeSelect.value === String(id)) {
                     absenceEmployeeSelect.value = "";
                     if(absencesTableBody) absencesTableBody.innerHTML = '<tr><td colspan="5">Gel√∂schter Mitarbeiter war ausgew√§hlt. Bitte Mitarbeiter ausw√§hlen.</td></tr>';
                     if(addAbsenceForm) addAbsenceForm.reset();
                     if(addAbsenceSubmitBtn) addAbsenceSubmitBtn.disabled = true;
                }
                if(balanceNameSelect && balanceNameSelect.options[balanceNameSelect.selectedIndex]?.text === name) {
                    balanceNameSelect.value = "";
                    if(balanceResultDiv) balanceResultDiv.innerHTML = '';
                    if(downloadPdfBtn) downloadPdfBtn.disabled = true;
                    currentBalanceData = null;
                }
                cancelEditEmployee(); // Falls Edit-Form offen war
                cancelEditWorkHours(); // Falls Arbeitszeit-Edit offen war
            } else {
                alert(`‚ùå Fehler beim L√∂schen (${response.status}): ${result}`);
            }
        } catch (error) {
            console.error(`Netzwerkfehler beim L√∂schen von Mitarbeiter ${id}:`, error);
            alert("‚ùå Netzwerkfehler beim L√∂schen des Mitarbeiters.");
        }
    }

    // === Funktionen f√ºr Abwesenheiten ===
    function handleAbsenceEmployeeSelectChange() {
        const selectedEmployeeId = absenceEmployeeSelect.value;
        const selectedEmployeeName = absenceEmployeeSelect.options[absenceEmployeeSelect.selectedIndex]?.textContent || 'Unbekannt';
        if (addAbsenceEmployeeIdInput) addAbsenceEmployeeIdInput.value = selectedEmployeeId; // Verstecktes Feld f√ºr Formular setzen
        if (addAbsenceSubmitBtn) addAbsenceSubmitBtn.disabled = !selectedEmployeeId; // Button aktivieren/deaktivieren
        if (absenceFormNote) absenceFormNote.style.display = selectedEmployeeId ? 'none' : 'block'; // Hinweis ein/ausblenden

        if (absencesTableBody) {
            if (selectedEmployeeId) {
                loadAbsences(selectedEmployeeId, selectedEmployeeName); // Abwesenheiten f√ºr gew√§hlten MA laden
            } else {
                 absencesTableBody.innerHTML = '<tr><td colspan="5">Bitte Mitarbeiter ausw√§hlen.</td></tr>'; // Platzhalter anzeigen
            }
        }
        if (addAbsenceForm) addAbsenceForm.reset(); // Formular immer zur√ºcksetzen bei Auswahlwechsel
        if (addAbsenceEmployeeIdInput && selectedEmployeeId) addAbsenceEmployeeIdInput.value = selectedEmployeeId; // ID neu setzen nach Reset
        if (deleteHolidaysResultDiv) deleteHolidaysResultDiv.innerHTML = ''; // Nachricht vom Feiertag-L√∂schen entfernen
    }

    async function loadAbsences(employeeId, employeeName) {
        if (!employeeId || !absencesTableBody) return;
        absencesTableBody.innerHTML = `<tr><td colspan="5">Lade Abwesenheiten f√ºr ${employeeName}...</td></tr>`;
        try {
            const response = await fetch(`/admin/absences?employeeId=${employeeId}`, { credentials: 'include' });
            if (!response.ok) throw new Error(`Fehler ${response.status} beim Laden der Abwesenheiten.`);
            const absences = await response.json();
            absencesTableBody.innerHTML = ''; // Tabelle leeren

            if (absences.length === 0) {
                 absencesTableBody.innerHTML = `<tr><td colspan="5">Keine Abwesenheiten f√ºr ${employeeName} erfasst.</td></tr>`;
            } else {
                absences.forEach(absence => {
                    const row = absencesTableBody.insertRow();
                    let displayDate = absence.date;
                    try {
                        // Datum kommt als YYYY-MM-DD String oder Date Objekt
                        const dateStr = (absence.date instanceof Date) ? absence.date.toISOString().split('T')[0] : String(absence.date).split('T')[0];
                        const dateObj = new Date(dateStr + 'T00:00:00Z');
                        // ** NEUE FORMATIERUNG **
                        displayDate = dateObj.toLocaleDateString('de-DE', dateDisplayOptionsUTC);
                    } catch(e) { console.warn("Fehler Datumskonvertierung Abwesenheit:", absence.date, e); }

                    let typeText = absence.absence_type;
                    switch(absence.absence_type) {
                        case 'VACATION': typeText = 'Urlaub'; break;
                        case 'SICK': typeText = 'Krank'; break;
                        case 'PUBLIC_HOLIDAY': typeText = 'Feiertag'; break;
                        default: typeText = absence.absence_type; // Falls unbekannt
                    }

                    row.insertCell().textContent = displayDate; // <- Verwendet formatiertes Datum
                    row.insertCell().textContent = typeText;
                    row.insertCell().textContent = (absence.credited_hours || 0).toFixed(2);
                    row.insertCell().textContent = absence.comment || '';

                    const actionCell = row.insertCell();
                    const deleteButton = document.createElement('button');
                    deleteButton.innerHTML = 'üóëÔ∏è'; // Emoji statt Text
                    deleteButton.title = 'Abwesenheit l√∂schen';
                    deleteButton.style.color = 'red';
                    deleteButton.style.backgroundColor = 'transparent';
                    deleteButton.style.border = 'none';
                    deleteButton.style.padding = '2px 6px';
                    deleteButton.style.cursor = 'pointer';
                    deleteButton.onclick = () => deleteAbsence(absence.id, employeeId, employeeName);
                    actionCell.appendChild(deleteButton);
                });
            }
        } catch (error) {
            console.error(`Fehler beim Laden der Abwesenheiten f√ºr Mitarbeiter ID ${employeeId}:`, error);
            absencesTableBody.innerHTML = `<tr><td colspan="5" class="error-message">‚ùå Fehler: ${error.message}</td></tr>`;
        }
    }

    async function handleAddAbsence(event) {
        event.preventDefault();
        if(!addAbsenceEmployeeIdInput || !addAbsenceDateInput || !addAbsenceTypeSelect || !addAbsenceSubmitBtn) return;

        const employeeId = addAbsenceEmployeeIdInput.value;
        const date = addAbsenceDateInput.value;
        const absenceType = addAbsenceTypeSelect.value;
        const comment = addAbsenceCommentInput.value.trim();
        const employeeName = absenceEmployeeSelect.options[absenceEmployeeSelect.selectedIndex]?.textContent || 'Unbekannt';

        if (!employeeId || !date || !absenceType) {
            alert("Bitte Mitarbeiter, Datum und Abwesenheitstyp ausw√§hlen/eingeben.");
            return;
        }

        addAbsenceSubmitBtn.disabled = true;
        addAbsenceSubmitBtn.textContent = 'Speichern...';

        try {
            const response = await fetch('/admin/absences', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ employeeId, date, absenceType, comment }),
                credentials: 'include'
            });

            if (!response.ok) {
                 const errorResult = await response.text();
                 // Versuchen, JSON zu parsen f√ºr detailliertere Fehlermeldung
                 let parsedError = { message: errorResult || `Serverfehler ${response.status}`};
                 try { parsedError = JSON.parse(errorResult); } catch(e) {}
                 throw new Error(parsedError.message);
            }

            const result = await response.json();
            // Formatierung f√ºr Alert
            let displayDateAlert = result.date;
            try { displayDateAlert = new Date(result.date+'T00:00:00Z').toLocaleDateString('de-DE',{timeZone:'UTC'}); } catch(e) {}
            let typeText = result.absence_type;
            switch(result.absence_type) {
                 case 'VACATION': typeText = 'Urlaub'; break;
                 case 'SICK': typeText = 'Krank'; break;
                 case 'PUBLIC_HOLIDAY': typeText = 'Feiertag'; break;
            }

            alert(`‚úÖ Abwesenheit (${typeText} am ${displayDateAlert}) f√ºr ${employeeName} gespeichert.`);
            addAbsenceForm.reset(); // Formular zur√ºcksetzen
            addAbsenceEmployeeIdInput.value = employeeId; // Employee ID wieder setzen f√ºr weitere Eingaben
            loadAbsences(employeeId, employeeName); // Tabelle neu laden
        } catch (error) {
            console.error("Fehler beim Hinzuf√ºgen der Abwesenheit:", error);
            alert(`‚ùå Fehler beim Speichern: ${error.message}`);
        } finally {
            addAbsenceSubmitBtn.disabled = !addAbsenceEmployeeIdInput.value; // Deaktivieren wenn kein MA mehr gew√§hlt ist (sollte nicht passieren hier)
            addAbsenceSubmitBtn.textContent = 'Speichern';
        }
    }

    async function deleteAbsence(absenceId, employeeId, employeeName) {
         if (!confirm(`Sind Sie sicher, dass Sie den Abwesenheitseintrag (ID: ${absenceId}) f√ºr ${employeeName} l√∂schen m√∂chten?`)) return;
         try {
             const response = await fetch(`/admin/absences/${absenceId}`, {
                 method: 'DELETE',
                 credentials: 'include'
             });
             const resultText = await response.text();
             if (response.ok) {
                 alert("‚úÖ Abwesenheitseintrag erfolgreich gel√∂scht.");
                 loadAbsences(employeeId, employeeName); // Tabelle neu laden
             } else {
                 alert(`‚ùå Fehler beim L√∂schen (${response.status}): ${resultText}`);
             }
         } catch (error) {
             console.error(`Netzwerkfehler beim L√∂schen von Abwesenheit ${absenceId}:`, error);
             alert("‚ùå Netzwerkfehler beim L√∂schen der Abwesenheit.");
         }
    }

    async function handleGenerateHolidays() {
        if (!generateHolidaysYearInput || !generateHolidaysBtn || !generateHolidaysResultDiv) {
             console.error("Fehler: Wichtige Elemente f√ºr die Feiertagsgenerierung fehlen.");
             alert("Ein interner Fehler ist aufgetreten (UI-Elemente fehlen).");
             return;
        }
        const year = generateHolidaysYearInput.value;
        const currentYear = new Date().getFullYear();
        const minYear = currentYear - 5; // Sinnvoller Bereich einschr√§nken
        const maxYear = currentYear + 5;

        if (!year || isNaN(parseInt(year)) || year < minYear || year > maxYear) {
            alert(`Bitte geben Sie ein g√ºltiges Jahr zwischen ${minYear} und ${maxYear} ein.`);
            generateHolidaysResultDiv.textContent = 'Ung√ºltiges Jahr.';
            generateHolidaysResultDiv.className = 'error-message';
            return;
        }

        if (!confirm(`Sollen die gesetzlichen Feiertage f√ºr das Jahr ${year} f√ºr alle Mitarbeiter automatisch eingetragen werden?\n\nBedingungen:\n- Nur f√ºr Tage Mo-Fr.\n- Nur wenn der Mitarbeiter an diesem Tag Soll-Stunden hat.\n- Bestehende Eintr√§ge (egal welchen Typs) f√ºr diesen Tag werden NICHT √ºberschrieben.`)) {
             return; // Benutzer hat abgebrochen
        }

        generateHolidaysResultDiv.textContent = `Generiere Feiertage f√ºr ${year}... Bitte warten.`;
        generateHolidaysResultDiv.className = 'working-message';
        generateHolidaysBtn.disabled = true;

        try {
            const response = await fetch('/admin/generate-holidays', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ year: parseInt(year) }),
                credentials: 'include'
            });

            if (response.ok) {
                 const resultData = await response.json();
                 generateHolidaysResultDiv.textContent = `‚úÖ ${resultData.message || 'Erfolgreich.'} (${resultData.generated} erstellt, ${resultData.skipped} √ºbersprungen f√ºr ${resultData.employees} Mitarbeiter).`;
                 generateHolidaysResultDiv.className = 'success-message';
                 // Tabelle aktualisieren, wenn ein Mitarbeiter ausgew√§hlt ist
                 if (absenceEmployeeSelect && absenceEmployeeSelect.value) {
                     const employeeName = absenceEmployeeSelect.options[absenceEmployeeSelect.selectedIndex]?.textContent || 'Ausgew√§hlter MA';
                     loadAbsences(absenceEmployeeSelect.value, employeeName);
                 }
            } else {
                const errorText = await response.text();
                console.error(`Fehler vom Server (${response.status}) bei Feiertagsgenerierung: ${errorText}`);
                let displayError = `‚ùå Fehler ${response.status}: ${errorText || 'Unbekannter Serverfehler.'}`;
                 try { // Versuche JSON zu parsen f√ºr bessere Fehlermeldung
                     const errorJson = JSON.parse(errorText);
                     displayError = `‚ùå Fehler ${response.status}: ${errorJson.message || errorText}`;
                 } catch(e) {}
                 // Spezifische Behandlung f√ºr 403 Forbidden (Session abgelaufen?)
                 if (response.status === 403 && displayError.toLowerCase().includes('zugriff verweigert')) {
                     displayError = `‚ùå Fehler ${response.status}: Zugriff verweigert. Bitte als Admin anmelden. Ihre Sitzung ist m√∂glicherweise abgelaufen.`;
                 }
                 generateHolidaysResultDiv.textContent = displayError;
                 generateHolidaysResultDiv.className = 'error-message';
            }
        } catch (error) {
            console.error("Fehler bei Feiertagsgenerierung (Fetch oder Parsing):", error);
            generateHolidaysResultDiv.textContent = '‚ùå Netzwerkfehler oder Server antwortet nicht/inkorrekt.';
            generateHolidaysResultDiv.className = 'error-message';
        } finally {
            generateHolidaysBtn.disabled = false;
        }
    }

    async function handleDeleteAllPublicHolidays() {
         if (!deleteAllPublicHolidaysBtn || !deleteHolidaysResultDiv) {
             console.error("Button oder Ergebnis-Div zum L√∂schen von Feiertagen fehlt."); return;
         }
         if (!confirm("WARNUNG!\n\nSind Sie sicher, dass Sie ALLE Abwesenheitseintr√§ge vom Typ 'Feiertag' f√ºr ALLE Mitarbeiter unwiderruflich l√∂schen m√∂chten?\n\nDies kann nicht r√ºckg√§ngig gemacht werden! Urlaub und Krankmeldungen bleiben bestehen.")) {
             deleteHolidaysResultDiv.textContent = 'L√∂schvorgang abgebrochen.';
             deleteHolidaysResultDiv.className = ''; // Reset class
             return;
         }

         deleteAllPublicHolidaysBtn.disabled = true;
         deleteAllPublicHolidaysBtn.textContent = 'Wird gel√∂scht...';
         deleteHolidaysResultDiv.textContent = 'L√∂sche Feiertagseintr√§ge...';
         deleteHolidaysResultDiv.className = 'working-message';

         try {
             const response = await fetch('/admin/delete-public-holidays', {
                 method: 'DELETE',
                 headers: { }, // Keine speziellen Header n√∂tig
                 credentials: 'include'
             });
             if (!response.ok) {
                 const errorText = await response.text();
                 let displayError = `Serverfehler ${response.status}`;
                 try { displayError = JSON.parse(errorText).message || errorText;} catch(e){}
                 throw new Error(displayError);
             }
             const result = await response.json();
             deleteHolidaysResultDiv.textContent = `‚úÖ ${result.message || 'Alle Feiertagseintr√§ge erfolgreich gel√∂scht.'}`;
             deleteHolidaysResultDiv.className = 'success-message';
             // Tabelle aktualisieren, wenn ein Mitarbeiter ausgew√§hlt ist
             if (absenceEmployeeSelect && absenceEmployeeSelect.value) {
                 const employeeName = absenceEmployeeSelect.options[absenceEmployeeSelect.selectedIndex]?.textContent || 'Ausgew√§hlter MA';
                 loadAbsences(absenceEmployeeSelect.value, employeeName);
             }
         } catch (error) {
             console.error("Fehler beim L√∂schen der Feiertagseintr√§ge:", error);
             deleteHolidaysResultDiv.textContent = `‚ùå Fehler beim L√∂schen: ${error.message}`;
             deleteHolidaysResultDiv.className = 'error-message';
         } finally {
             deleteAllPublicHolidaysBtn.disabled = false;
             deleteAllPublicHolidaysBtn.textContent = "Alle 'Feiertag'-Eintr√§ge l√∂schen (Vorsicht!)";
         }
    }

    // === Auswertungen ===
    function handlePeriodTypeChange() {
        if(!periodTypeSelect || !monthSelectDiv || !quarterSelectDiv || !balanceMonthInput || !balanceQuarterSelect || !downloadPdfBtn || !balanceResultDiv) return;

        const selectedType = periodTypeSelect.value;
        monthSelectDiv.classList.toggle('hidden', selectedType !== 'MONTH');
        quarterSelectDiv.classList.toggle('hidden', selectedType !== 'QUARTER');

        // Setze 'required' Attribut dynamisch
        balanceMonthInput.required = (selectedType === 'MONTH');
        balanceQuarterSelect.required = (selectedType === 'QUARTER');

        // Button-Text anpassen
        let pdfButtonTitle = "PDF Herunterladen";
        if (selectedType === 'MONTH') pdfButtonTitle = "Monats√ºbersicht als PDF";
        else if (selectedType === 'QUARTER') pdfButtonTitle = "Quartals√ºbersicht als PDF";
        else pdfButtonTitle = "Jahres√ºbersicht als PDF";
        downloadPdfBtn.title = pdfButtonTitle;

        // Status zur√ºcksetzen
        downloadPdfBtn.disabled = true;
        balanceResultDiv.innerHTML = '';
        currentBalanceData = null; // Keine Daten mehr f√ºr PDF verf√ºgbar
    }

    async function handleCalculateBalance(e) {
        e.preventDefault();
        if(!balanceNameSelect || !balanceYearInput || !periodTypeSelect || !balanceMonthInput || !balanceQuarterSelect || !balanceResultDiv || !downloadPdfBtn) return;

        const employeeName = balanceNameSelect.value;
        const year = balanceYearInput.value;
        const selectedType = periodTypeSelect.value;
        let month = null, quarter = null, url = '', valid = true;

        if (!employeeName) { alert("Bitte einen Mitarbeiter ausw√§hlen."); valid = false; }
        if (!year || isNaN(parseInt(year)) || year.length !== 4) { alert("Bitte ein g√ºltiges Jahr (YYYY) eingeben."); valid = false; }

        if (selectedType === 'MONTH') {
            month = balanceMonthInput.value;
            if (!month || isNaN(parseInt(month)) || month < 1 || month > 12) { alert("Bitte einen g√ºltigen Monat (1-12) eingeben."); valid = false; }
            else { url = `/calculate-monthly-balance?name=${encodeURIComponent(employeeName)}&year=${year}&month=${month}`; }
        } else if (selectedType === 'QUARTER') {
            quarter = balanceQuarterSelect.value;
            if (!quarter) { alert("Bitte ein Quartal ausw√§hlen."); valid = false; }
            else { url = `/calculate-period-balance?name=${encodeURIComponent(employeeName)}&year=${year}&periodType=QUARTER&periodValue=${quarter}`; }
        } else { // YEAR
            url = `/calculate-period-balance?name=${encodeURIComponent(employeeName)}&year=${year}&periodType=YEAR`;
        }

        if (!valid || !url) return; // Abbruch, wenn Eingaben ung√ºltig

        balanceResultDiv.innerHTML = "Berechne Auswertung...";
        balanceResultDiv.className = 'working-message';
        downloadPdfBtn.disabled = true; // PDF Button deaktivieren
        currentBalanceData = null;

        try {
            const response = await fetch(url, { credentials: "include" });
            const responseText = await response.text(); // Immer erst Text lesen
            if (!response.ok) {
                let errorMsg = `Fehler ${response.status}`;
                try { errorMsg = JSON.parse(responseText).message || responseText; } catch(e) {} // Versuche JSON zu parsen
                throw new Error(errorMsg);
            }
            const data = JSON.parse(responseText); // Jetzt JSON parsen
            currentBalanceData = data; // Daten f√ºr PDF speichern
            let html = '';
            balanceResultDiv.className = ''; // Meldungs-Klasse entfernen

            // Hilfsfunktion f√ºr Datumsformatierung der Periodenanzeige
            const formatPeriodDateForDisplay = (dateStr) => {
                if (!dateStr) return 'N/A';
                try {
                    const dateObj = new Date(dateStr + 'T00:00:00Z'); // Als UTC behandeln
                    return dateObj.toLocaleDateString('de-DE', dateDisplayOptionsUTC); // Mit Wochentag
                } catch(e) { return dateStr; }
            };

            if (selectedType === 'MONTH') {
                html = `<h3>Monatsauswertung f√ºr ${data.employeeName || employeeName} (${String(data.month).padStart(2,'0')}/${data.year})</h3>`;
                if (data.totalExpected !== undefined) { // Pr√ºfen ob g√ºltige Daten da sind
                    html += `<p>√úbertrag Vormonat: <strong>${data.previousCarryOver.toFixed(2)} Std.</strong></p>`;
                    html += `<p>Soll-Stunden (Monat): <strong>${data.totalExpected.toFixed(2)} Std.</strong></p>`;
                    html += `<p>Ist-Stunden (Monat): <strong>${data.totalActual.toFixed(2)} Std.</strong> (Gearbeitet: ${data.workedHours?.toFixed(2) || '0.00'} Std. + Abwesenheit: ${data.absenceHours?.toFixed(2) || '0.00'} Std.)</p>`;
                    html += `<p>Differenz (Monat): <strong class="${data.totalDifference >= 0 ? 'positive-diff' : 'negative-diff'}">${data.totalDifference.toFixed(2)} Std.</strong></p>`;
                    html += `<hr style="border-color:#ccc; margin: 10px 0;">`;
                    html += `<p><strong>Neuer √úbertrag (Saldo Ende Monat): <strong>${data.newCarryOver.toFixed(2)} Std.</strong></p>`;
                    downloadPdfBtn.disabled = false; // PDF Button aktivieren
                } else {
                     html += `<p class="error-message">${data.message || 'Keine Daten f√ºr diesen Monat gefunden.'}</p>`;
                     balanceResultDiv.className = 'error-message';
                }
            } else { // QUARTER or YEAR
                const periodLabel = data.periodIdentifier || (selectedType === 'QUARTER' ? `Q${quarter}` : 'Jahr');
                const sd = formatPeriodDateForDisplay(data.periodStartDate); // Mit Wochentag
                const ed = formatPeriodDateForDisplay(data.periodEndDate); // Mit Wochentag

                html = `<h3>Auswertung ${periodLabel} f√ºr ${data.employeeName || employeeName} (${data.year})</h3>`;
                html += `<p>Zeitraum: ${sd} - ${ed}</p>`; // Zeigt jetzt Wochentage an
                if (data.totalExpectedPeriod !== undefined) { // Pr√ºfen ob g√ºltige Daten da sind
                    html += `<p>√úbertrag Periodenbeginn: <strong>${data.startingBalance.toFixed(2)} Std.</strong></p>`;
                    html += `<p>Soll-Stunden (${periodLabel}): <strong>${data.totalExpectedPeriod.toFixed(2)} Std.</strong></p>`;
                    html += `<p>Ist-Stunden (${periodLabel}): <strong>${data.totalActualPeriod.toFixed(2)} Std.</strong> (Gearbeitet: ${data.workedHoursPeriod?.toFixed(2) || '0.00'} Std. + Abwesenheit: ${data.absenceHoursPeriod?.toFixed(2) || '0.00'} Std.)</p>`;
                    html += `<p>Differenz (${periodLabel}): <strong class="${data.periodDifference >= 0 ? 'positive-diff' : 'negative-diff'}">${data.periodDifference.toFixed(2)} Std.</strong></p>`;
                    html += `<hr style="border-color:#ccc; margin: 10px 0;">`;
                    html += `<p><strong>Neuer √úbertrag (Saldo Periodenende): <strong>${data.endingBalancePeriod.toFixed(2)} Std.</strong></p>`;
                    downloadPdfBtn.disabled = false; // PDF Button aktivieren
                } else {
                    html += `<p class="error-message">${data.message || 'Keine Daten f√ºr diesen Zeitraum gefunden.'}</p>`;
                    balanceResultDiv.className = 'error-message';
                }
            }
            balanceResultDiv.innerHTML = html; // Ergebnis anzeigen
        } catch (error) {
            console.error(`Fehler bei der ${selectedType}-Auswertung:`, error);
            balanceResultDiv.innerHTML = `<p class="error-message">Fehler bei der Berechnung: ${error.message}</p>`;
            balanceResultDiv.className = 'error-message';
            downloadPdfBtn.disabled = true; // PDF Button deaktiviert lassen
            currentBalanceData = null;
        }
    }

    function handleDownloadPdf() {
        if (!currentBalanceData) {
            alert("Bitte zuerst eine Auswertung berechnen, bevor das PDF heruntergeladen werden kann.");
            return;
        }
        if (!periodTypeSelect || !balanceNameSelect || !balanceYearInput || !balanceMonthInput || !balanceQuarterSelect) {
            console.error("PDF Download: Formular-Elemente nicht gefunden.");
            return;
        }

        const selectedType = periodTypeSelect.value;
        const name = currentBalanceData.employeeName || balanceNameSelect.value;
        const year = currentBalanceData.year || balanceYearInput.value;
        let pdfUrl = '', valid = true;

        if (!name || name === 'Bitte ausw√§hlen...' || !year) {
            alert("Fehler: Mitarbeitername oder Jahr f√ºr PDF-Generierung nicht verf√ºgbar.");
            return;
        }

        if (selectedType === 'MONTH') {
            const month = currentBalanceData.month || balanceMonthInput.value;
            if (!month || isNaN(parseInt(month)) || month < 1 || month > 12) {
                alert("Fehler: Ung√ºltiger Monat f√ºr PDF.");
                valid = false;
            } else {
                pdfUrl = `/api/pdf/create-monthly-pdf?name=${encodeURIComponent(name)}&year=${year}&month=${month}`;
            }
        } else if (selectedType === 'QUARTER') {
            const quarter = currentBalanceData.periodValue || balanceQuarterSelect.value;
            if (!quarter || isNaN(parseInt(quarter)) || quarter < 1 || quarter > 4) {
                alert("Fehler: Ung√ºltiges Quartal f√ºr PDF.");
                valid = false;
            } else {
                pdfUrl = `/api/pdf/create-period-pdf?name=${encodeURIComponent(name)}&year=${year}&periodType=QUARTER&periodValue=${quarter}`;
            }
        } else { // YEAR
            pdfUrl = `/api/pdf/create-period-pdf?name=${encodeURIComponent(name)}&year=${year}&periodType=YEAR`;
        }

        if (!valid || !pdfUrl) {
            console.error("PDF URL konnte nicht erstellt werden. Typ:", selectedType, "Valid:", valid);
            alert("Fehler beim Erstellen der PDF-Download-URL.");
            return;
        }

        // KORRIGIERTER CODE: Nur der fetch-Block
        console.log("Versuche PDF herunterzuladen von:", pdfUrl); // Zus√§tzliches Logging

        fetch(pdfUrl)
            .then(response => {
                if (!response.ok) {
                    // Fehler vom Server (z.B. 404, 500)
                    // Versuchen, eine genauere Fehlermeldung aus dem Body zu lesen
                     return response.text().then(text => {
                        let errorMsg = `Netzwerkantwort war nicht ok: ${response.status} ${response.statusText}`;
                        if (text) {
                            errorMsg += ` - Servermeldung: ${text}`;
                        }
                         throw new Error(errorMsg);
                    });
                }
                // Versuche, den Dateinamen aus dem Header zu bekommen, sonst Fallback
                const contentDisposition = response.headers.get('content-disposition');
                let filename = 'download.pdf'; // Fallback-Name
                if (contentDisposition) {
                   const filenameMatch = contentDisposition.match(/filename="?(.+?)"?$/i); // case-insensitive match
                    if (filenameMatch && filenameMatch.length > 1) {
                        filename = filenameMatch[1];
                    }
                }
                console.log(`Server antwortete OK. Erwarteter Dateiname: ${filename}`);
                return response.blob().then(blob => ({ blob, filename })); // Beides weitergeben
            })
            .then(({ blob, filename }) => {
                // Einen tempor√§ren Link erstellen
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                 link.href = url;
                link.setAttribute('download', filename); // Den Dateinamen setzen

                // Den Link zum DOM hinzuf√ºgen (n√∂tig f√ºr manche Browser), klicken und wieder entfernen
                document.body.appendChild(link);
                link.click();
                 link.parentNode.removeChild(link);

                // Den Object-URL wieder freigeben, nachdem der Klick verarbeitet wurde (mit kleiner Verz√∂gerung)
                setTimeout(() => window.URL.revokeObjectURL(url), 100);

                console.log("Download wurde ausgel√∂st f√ºr:", filename);
            })
             .catch(error => {
                // Fehler beim fetch oder bei der Verarbeitung
                console.error('Fehler beim Herunterladen oder Verarbeiten des PDFs:', error);
                alert(`Fehler beim PDF-Download: ${error.message}`);
            });
        // --- ENDE DER KORREKTUR ---
    }
    // --- ENDE Auswertungen ---

  </script>
</body>
</html>
